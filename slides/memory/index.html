<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Google DevTools를 이용한 Web Application Memory 분석법</title>
	<meta name="description" content="JavaScript Memory">
	<meta name="author" content="sculove. 손찬욱">
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="../../reveal.js-3.3.0/css/reveal.css">
	<link rel="stylesheet" href="../../reveal.js-3.3.0/css/theme/black.css">
	<link rel="stylesheet" href="../../reveal.js-3.3.0/custom.css">
	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="../../reveal.js-3.3.0/lib/css/darkula.css">
	<script src="../../reveal.js-3.3.0/custom_head.js"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
	<section>
		<h3>Google DevTools를 이용한</h3>
    <h1>Web Application Memory 분석법</h1>
	</section>
	<section data-background="#1A3819">
		<h2>Memory Leak</h2>
		<blockquote>a memory leak is a type of <strong>resource leak</strong> that occurs when a computer program incorrectly manages memory allocations in such a way that <em>memory which is no longer needed is not released</em></blockquote>
	</section>
	<section>
		<h2>Memory Leak 징후</h2>
		<ul>
			<li class="fragment">페이지가 느리다.</li>
		 	<li class="fragment">페이지가 시간이 지날수록 점점 느려진다.</li>
		   	<li class="fragment">단말기 마다, 환경마다 증상의 차이가 크다.</li>
		 	<li class="fragment">페이지의 동작이 잠시 멈춘다.</li>
		 	<li class="fragment">브라우저가 죽는다(crashed)
		 	</li>
		</ul>
	</section>
	<section>
		<h2>왜 Memory leak은 발생하는가?</h2>
		<h3 class="fragment"><strong>잘못 사용된 개발 패턴</strong></h3>
	</section>
	<section>
		<h2>전 별로 신경쓰지 않았는데...</h2>
		<h2>잘 되던데요 ^^</h2>
		<h3 class="fragment"><em>네. 맞습니다</em></h3>
	</section>
	<section>
		<h2>모던 브라우저는 <strong>Reloading</strong>시 메모리를 효과적으로 릴리즈합니다.</h2>
	</section>
	<section>
		<h2>하지만, 당신이 개발하는 서비스가 <em>SPA</em>라면 상황은 달라집니다</h2>
		<small>SPA : Single-Page Application</small>
	</section>
	<section>
		<h1>Memory</h1>
	</section>
	<section>
		<h3>Think of memory as a graph</h3>
		<img src="./images/thinkgraph.png"/>
	</section>
	<section>
		<h2>Types</h2>
		<ul>
			<li>
				<div>Primitive types : Number, Boolen, String</div>
				<em class="fragment">다른 값의 reference를 갖을 수 없음</em>
			</li>

			<li class="fragment">
				<div>Object(key-value), Array<i>(number key-value)</i></div>
				<em class="fragment">다른 값의 reference를 가짐</em>
				<div><strong class="fragment">Memory leak 관리 대상</strong></div>
			</li>
		</ul>
	</section>
	<section>
		<img src="./images/dontcontrol.png"/>
		<!-- <p>Root는 <em>window</em> 객체</p> -->
		<p>Object는 <em>Object와 Array</em></p>
	</section>
	<section>
		<h3>GC (Garbage Collection)</h3>
		<img src="./images/gc.png"/>
		<p class="fragment"><strong>Root와 연결이 끊어진 node</strong>의 메모리를 해제하는 작업</p>
	</section>
	<section>
		<h3>Memory Leak을 제거 하는 방법</h3>
		<p>사용한 <em>Object, Array</em>의 Reference가<p>
		<p><strong>Root와 연결되지 않도록 한다.</strong></p>
	</section>
	<section data-background="#1A3819">
		<h3>Memory Leak이 발생 할 수 있는</h3>
		<h2>3가지 개발 패턴</h2>
	</section>
	<section>
		<h2>1. Timers</h2>
	</section>
	<section>
		<pre><code data-noescape>var buggyObject = {
	callAgain: function () {
		<span class="fragment highlight-red" data-fragment-index="2">var ref = this;</span>
		var val = setTimeout(function () {
			console.log('Called again: '
				+ new Date().toTimeString());
			ref.callAgain();
		}, 1000);
	}
};

buggyObject.callAgain();
<mark class="fragment" data-fragment-index="1">buggyObject = null; // buggyObject reference 제거</mark>
</code></pre>
		<p class="fragment" data-fragment-index="2">timer 내부에서 buggyObject reference가 여전히 존재함</p>
	</section>
	<section>
		<pre><code data-noescape>var buggyObject = {
	callAgain: function () {
		<mark>function loopFunc() {</mark>
			console.log('Called again: '
				+ new Date().toTimeString());
			setTimeout(loopFunc, 1000);
		<mark>}</mark>
		<mark>setTimeout(loopFunc, 1000);</mark>
	}
};

buggyObject.callAgain();
buggyObject = null; // buggyObject reference 제거
</code></pre>
		<p>timer 내부에서 buggyObject reference를 사용하지 않는다.</p>
	</section>
	<section>
    	<h2>2. Closures</h2>
    	<blockquote>외부함수의 변수에 접근할 수 있는 내부 함수.<br>
    	함수와 그 함수가 만들어진 환경으로 이루어진 객체
    	</blockquote>
    </section>
	<section>
		<pre><code data-noescape>var a = function () {
	var largeStr = new Array(1000000).join('x');
	return <mark>function () {</mark>
	 return <span class="fragment highlight-red" data-fragment-index="1">largeStr;</span>
	<mark>};</mark>
}();
</code></pre>
		<p class="fragment" data-fragment-index="1">반환된 closure는 largeStr 변수의 레퍼런스가 가지고 있음</p>
	</section>
	<section>
		Closure는 실용적인 프로그래밍을 할수 있습니다.

		<p class="fragment">하지만, <strong>무분별한 Closure</strong>는 Memory leak을 유발합니다.</p>
	</section>
	<section>
    	<h2>3. DOM leaks</h2>
    	<img src="images/dom.png"/>
    </section>
    <section>
    	<blockquote>DOM node는 <em>DOM Tree에서 삭제</em>되었지만, 여전히 <strong>DOM node의 reference가 존재</strong>하는 경우
    	</blockquote>
    </section>
	<section>
		<div style="float:left;width:50%">
			<img src="images/dom_ex.png"/>
		</div>
		<div style="float:left;width:50%">
			<pre><code data-noescape>var select = document.querySelector;
var <span class="fragment highlight-red" data-fragment-index="1">treeRef</span> = select("#tree");
var <span class="fragment highlight-blue" data-fragment-index="2">leafRef</span> = select("#leaf");
var body = select("body");

<mark>body.removeChild(treeRef);</mark>

<mark class="fragment" data-fragment-index="1">treeRef = null;</mark>

<mark class="fragment" data-fragment-index="2">leafRef = null;</mark>
</code></pre>
		</div>
		<div style="clear:both">
			<p class="fragment" data-fragment-index="1"><strong>treeRef</strong> 때문에, GC가 발생하지 않음</p>
			<p class="fragment" data-fragment-index="2"><em>leafRef</em> 때문에, GC가 발생하지 않음</p>
		</div>
	</section>
	<section>
    	<h3>Event listeners</h3>
    </section>
    <section>
		<pre><code data-noescape>var Area = document.getElementById('area');
function addNote(index) {
  var note = <span class="fragment highlight-red" data-fragment-index="1">document.createElement('DIV');</span>
  note.id = 'note' + index;
  note.innerHTML = '&lt;div&gt;노트 입니다.&lt;button class="close"&gt;&lt;/div&gt;';
  Area.appendChild(note);
  <span class="fragment highlight-red" data-fragment-index="2">note.querySelector('button.close').addEventListener('click', onClickClose);</span>
}
function removeNote(index) {
  var note = document.getElementById(id);
  Area.removeChild(note);
  <mark class="fragment" data-fragment-index="5">note.querySelector('button.close').removeEventListener('click', onClickClose);</mark>
}
<mark class="fragment" data-fragment-index="3">addNote(0); removeNote(0);
addNote(1); removeNote(1);</mark>
</code></pre>
		<p class="fragment" data-fragment-index="4"><em>이벤트</em>를 dettach 하지 않기 때문에, GC가 발생하지 않음</p>
	</section>
	<section>
		<pre><code data-noescape>var Area = document.getElementById('area');
function addNote(index) {
  var note = document.createElement('DIV');
  note.id = 'note' + index;
  note.innerHTML = '&lt;div&gt;노트 입니다.&lt;button class="close"&gt;&lt;/div&gt;';
  Area.appendChild(note);
}
function removeNote(index) {
  Area.removeChild(document.getElementById(id));
}
<mark>function handler(e) {
	if(e.target.nodeName === 'button'
		&amp;&amp; e.target.classList.contains('close') ) {
		onClickClose(e);
	}
}</mark>
<mark>Area.addEventListener('click', handler);</mark>
addNote(0); removeNote(0);
addNote(1); removeNote(1);
<mark>Area.removeEventListener('click', handler);</mark></code></pre>
		<p><em>이벤트 delegate</em>을 이용하여 개발</p>
	</section>
	<section data-background="#1A3819">
  	<h3>Chrome DevTools를 이용한</h3>
  	<h2>Memory Leak 분석하기</h2>
  </section>
  <section>
  	<h3>문제를 해결하는 방법</h3>
    <ol>
    	<li class="fragment">문제를 <strong>재연</strong>시키고, 확인하라</li>
    	<li class="fragment">문제의 원인을 파악하라</li>
    	<li class="fragment">문제를 해결하라.</li>
    	<li class="fragment">목표점에 도달하기 까지 이를 <strong>반복</strong>하라.</li>
    </ol>
  </section>
  <section>
  	<h3>문제를 <strong>재연</strong>시키고, 확인하라</h3>
  	<ul>
  		<li class="fragment">현재 상태 확인</li>
  		<li class="fragment">문제 원인 유추</li>
  		<li class="fragment">목표 지표 확인</li>
  	</ul>
  </section>
  <section>
  	<h4>전체 메모리, CPU 사용량 보기</h4>
		<p>Task Manager (옵션 > 도구 더보기 > 작업관리자)</p>
		<img src="images/taskmanager.png"/>
  	<small>JavaScript Memory(JS Heap)와 Memory (DOM)</small>
	</section>
	<section>
    <h4>Timeline으로 확인하기 (1/3)</h4>
    <p>DevTools > Timeline tab, check `memory`</p>
    <img src="images/timeline.png"/>
    <small>확장 프로그램을 제외하기 위해, 시크릿 창으로 Chrome을 열어 확인한다</small>
  </section>
  <section>
  	<h4>Timeline으로 확인하기 (2/3)</h4>
    <ol>
    	<li>Record 시작</li>
    	<li>GC 버튼을 일정 시간 간격으로 몇차례 눌러, <strong>강제로 메모리를 릴리즈</strong>한다.</li>
    	<li>Record를 중지한다</li>
    </ol>
    <a href="../../demo/memory/grow.html" target="_blank">DEMO</a>
	</section>
  <section>
  	<h4>Timeline으로 확인하기 (3/3)</h4>
  	<p>Memory Leak이 존재하면 <strong>계단형</strong>의 timeline을 보임</p>
    <img src="images/grow.png"/>
    <p class="fragment">JS Heap이 <em>계단형</em>, Nodes가 <em>계단형</em></p>
    <p class="fragment">JS Heap이 <strong>Memory Leak</strong>, Nodes가 <strong>Memory Leak</strong></p>
	</section>
	<section>
  	<h3>2. 문제의 원인을 파악하라</h3>
  </section>
  <section>
  	<ul>
  		<li><strong>성능</strong>이 문제인가?
  			<ul class="fragment">
  				<li>Timeline을 통한 <em>Bottleneck</em> 확인</li>
  				<li>CPU Profile을 통한 <em>CPU 사용량</em> 확인</li>
  			</ul>
  		</li>
  		<div style="height:20px">&nbsp;</div>
  		<li class="fragment"><strong>메모리</strong>가 문제인가?
  			<ul class="fragment">
  				<li>Profile을 통한 <em>Memory leak</em> 확인</li>
  			</ul>
  		</li>
  	</ul>
  </section>
	<section>
		<h3>3. 문제를 해결하라</h3>
	</section>
	<section>
		<h3>Profile 하기</h3>
		<img src="images/profile.png"/>
		<small>profile 측정 전에 GC를 자동 실행한다</small>
	</section>
	<section>
		<h3>메모리 관련 툴</h3>
    <ul>
    	<li>
	    	Take Heap Snapshot
	      <div><em>JavaScript Object</em> and related <em>DOM nodes</em></div>
				<pre class="fragment"><code>kill -6 pid</code></pre>
    	</li>
    	<li class="fragment">
    		Record Allocation Timeline
    		<p class="fragment">시간 기준으로 할당과 해제를 반복하여, <strong>남겨진 메모리</strong>를 확인</p>
      </li>
      <li class="fragment">
        Record Allocation Profile
        <p class="fragment"><em>JavaScript 함수</em> 기준으로 메모리량 확인</p>
      </li>
    </ul>
  </section>
	<section>
  	<h3>Take Heap Snapshot</h3>
  	<p>Snapshot을 뜬 후, 비교를 통해 변경된 메모리 세부 내역을 확인한다</p>
  </section>
  <section>
		<h3>그 전에 알아야할 메모리 관련 용어 (1/2)</h3>
    <ul>
    	<li>
	    	Shallow Size
	      <p class="fragment">array, string와 같이 직접적으로 메모리를 점유하고 있는 JavaScript 객체들의 크기</p>
    	</li>
    	<li>
    		Retained Size
    		<p class="fragment">GC이후 남겨진 메모리의 크기. 즉, <strong>메모리를 해제할수 없는 JS Heap의 크기</strong></p>
      </li>
    </ul>
  </section>
	<section>
		<h3>그 전에 알아야할 메모리 관련 용어 (2/2)</h3>
    <p>Distance: GC root로 부터의 Retaining Path</p>
    <img src="images/path.png"/>
    <small>8의 distance는 4</small>
  </section>
  <section>
		<h3>메모리 툴의 view 타입</h3>
    <ul>
    	<li>
	    	Summary view
	      <p>constructor 이름으로 그룹지어 보여주는 뷰</p>
    	</li>
    	<li>
    		Compare view
    		<p>constructor 이름으로 그룹지어 표시하고, 2개의 Snapshot의 차이를 표시해주는 뷰</p>
    	</li>
    	<li>
    		Containment view
    		<p>JS Heap 메모리의 그래프를 표시</p>
    	</li>
    	<li>
    		Statistics View
    		<p>사용량을 그래프로 표시</p>
    	</li>
    </ul>
    <a href="../../demo/memory/view.html" target="_blank">DEMO</a>
  </section>
  <section>
  	<h3>Record Allocation Timeline</h3>
  	<p></p>
  </section>
  <section>
  	<h3>Record Allocation Profile</h3>
  	<p></p>
  </section>
  <section>
		<h2>Reference</h2>
		<ul style="font-size:24px;line-height:35px">
			<li>
				Effectively Managing Memory at Gmail scale<br>
				<a href="http://www.html5rocks.com/en/tutorials/memory/effectivemanagement/" target="_new">http://www.html5rocks.com/en/tutorials/memory/effectivemanagement/</a>
			</li>
			<li>
				Fix Memory Problems<br>
				<a href="https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en" target="_new">https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en</a>
			</li>
			<li>
				Finding and debugging memory leaks in JavaScript with Chrome DevTools<br>
				<a href="http://slides.com/gruizdevilla/memory" target="_new">http://slides.com/gruizdevilla/memory</a>
			</li>
			<li>
				nhnent/fe.javascript wiki<br>
				<a href="https://github.com/nhnent/fe.javascript/wiki/August-22-August-26,-2016" target="_new">https://github.com/nhnent/fe.javascript/wiki/August-22-August-26,-2016</a>
			</li>
		</ul>
	</section>
	<section>
		<h2>감사합니다.</h2>
		<br>
		<h3>BY <a href="http://sculove.github.io/blog/">손찬욱</a> / <a href="https://www.facebook.com/chanuk.son">chanuk.son</a></h3>
	</section>
</div>
</div>
<script src="../../reveal.js-3.3.0/lib/js/head.min.js"></script>
<script src="../../reveal.js-3.3.0/js/reveal.js"></script>
<script src="../../reveal.js-3.3.0/custom_init.js"></script>
<script>
// $("code[contenteditable]").focusout(function(e) {
// 	var $el = $(e.target);
// 	eval($el.text());
// });
</script>
</body>
</html>
